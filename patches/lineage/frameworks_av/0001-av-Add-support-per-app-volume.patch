From 8735962d31eb78fba833d1d11d6eeea1c3192249 Mon Sep 17 00:00:00 2001
From: cjybyjk <cjybyjk@zjnu.edu.cn>
Date: Mon, 5 Sep 2022 05:03:38 +0000
Subject: [PATCH] av: support per-app volume [1/3]

Signed-off-by: cjybyjk <cjybyjk@zjnu.edu.cn>
Change-Id: Ib22a04d7b99706042b903a223d0b3900c0838fbd
---
 Android.bp                                    |  1 +
 aidl/android/media/AppVolumeData.aidl         | 27 ++++++
 include/media/AppVolume.h                     | 85 +++++++++++++++++++
 media/libaudioclient/AudioSystem.cpp          | 21 +++++
 media/libaudioclient/IAudioFlinger.cpp        | 42 +++++++++
 .../android/media/IAudioFlingerService.aidl   |  5 ++
 .../include/media/AudioSystem.h               |  5 ++
 .../include/media/IAudioFlinger.h             | 16 ++++
 services/audioflinger/AudioFlinger.cpp        | 68 ++++++++++++++-
 services/audioflinger/AudioFlinger.h          |  8 ++
 services/audioflinger/PlaybackTracks.h        | 13 ++-
 services/audioflinger/Threads.cpp             | 56 ++++++++++--
 services/audioflinger/Threads.h               |  4 +
 services/audioflinger/Tracks.cpp              | 24 ++++++
 14 files changed, 367 insertions(+), 8 deletions(-)
 create mode 100644 aidl/android/media/AppVolumeData.aidl
 create mode 100644 include/media/AppVolume.h

diff --git a/Android.bp b/Android.bp
index 302e250a79..abfb791dc9 100644
--- a/Android.bp
+++ b/Android.bp
@@ -42,6 +42,7 @@ aidl_interface {
     double_loadable: true,
     local_include_dir: "aidl",
     srcs: [
+        "aidl/android/media/AppVolumeData.aidl",
         "aidl/android/media/InterpolatorConfig.aidl",
         "aidl/android/media/InterpolatorType.aidl",
         "aidl/android/media/MicrophoneInfoFw.aidl",
diff --git a/aidl/android/media/AppVolumeData.aidl b/aidl/android/media/AppVolumeData.aidl
new file mode 100644
index 0000000000..e0e38e8426
--- /dev/null
+++ b/aidl/android/media/AppVolumeData.aidl
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2022 Project Kaleidoscope
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.media;
+
+/**
+ * {@hide}
+ */
+parcelable AppVolumeData {
+    @utf8InCpp String packageName;
+    int muted;
+    float volume;
+    int active;
+}
diff --git a/include/media/AppVolume.h b/include/media/AppVolume.h
new file mode 100644
index 0000000000..5c12c11ae7
--- /dev/null
+++ b/include/media/AppVolume.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2022 Project Kaleidoscope
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef APP_VOLUME_H
+#define APP_VOLUME_H
+
+#include <android/media/AppVolumeData.h>
+#include <utils/String8.h>
+#include <binder/Parcel.h>
+#include <binder/Parcelable.h>
+#include <media/AidlConversionUtil.h>
+
+namespace android {
+namespace media {
+    class AppVolume : public Parcelable {
+    public:
+        String8 packageName;
+        bool muted;
+        float volume;
+        bool active;
+
+        bool operator <(const AppVolume &obj) const {
+            if (active != obj.active) return active < obj.active;
+            return packageName < obj.packageName;
+        }
+
+        virtual status_t writeToParcel(Parcel* parcel) const {
+            AppVolumeData parcelable;
+            return writeToParcelable(&parcelable)
+                ?: parcelable.writeToParcel(parcel);
+        }
+
+        virtual status_t writeToParcelable(AppVolumeData* parcelable) const {
+            parcelable->packageName = packageName.c_str();
+            parcelable->muted = muted;
+            parcelable->volume = volume;
+            parcelable->active = active;
+            return OK;
+        }
+
+        virtual status_t readFromParcel(const Parcel* parcel) {
+            AppVolumeData data;
+            return data.readFromParcel(parcel)
+                ?: readFromParcelable(data);
+        }
+
+        virtual status_t readFromParcelable(const AppVolumeData& parcelable) {
+            packageName = parcelable.packageName.c_str();
+            muted = parcelable.muted;
+            volume = parcelable.volume;
+            active = parcelable.active;
+            return OK;
+        }
+    };
+
+    inline ConversionResult<AppVolume>
+    aidl2legacy_AppVolume(const AppVolumeData& aidl) {
+        AppVolume legacy;
+        RETURN_IF_ERROR(legacy.readFromParcelable(aidl));
+        return legacy;
+    }
+
+    inline ConversionResult<AppVolumeData>
+    legacy2aidl_AppVolume(const AppVolume& legacy) {
+        AppVolumeData aidl;
+        RETURN_IF_ERROR(legacy.writeToParcelable(&aidl));
+        return aidl;
+    }
+} // namespace media
+};  // namespace android
+
+#endif // APP_VOLUME_H
diff --git a/media/libaudioclient/AudioSystem.cpp b/media/libaudioclient/AudioSystem.cpp
index 7cec2e8879..9c3c1f49b6 100644
--- a/media/libaudioclient/AudioSystem.cpp
+++ b/media/libaudioclient/AudioSystem.cpp
@@ -2592,6 +2592,27 @@ status_t AudioSystem::registerSoundTriggerCaptureStateListener(
     return NO_ERROR;
 }
 
+status_t AudioSystem::setAppVolume(const String8& packageName, const float volume)
+{
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->setAppVolume(packageName, volume);
+}
+
+status_t AudioSystem::setAppMute(const String8& packageName, const bool mute)
+{
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->setAppMute(packageName, mute);
+}
+
+status_t AudioSystem::listAppVolumes(std::vector<media::AppVolume> *vols)
+{
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->listAppVolumes(vols);
+}
+
 status_t AudioSystem::setVibratorInfos(
         const std::vector<media::AudioVibratorInfo>& vibratorInfos) {
     const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
diff --git a/media/libaudioclient/IAudioFlinger.cpp b/media/libaudioclient/IAudioFlinger.cpp
index 7caaaaf226..74df84a231 100644
--- a/media/libaudioclient/IAudioFlinger.cpp
+++ b/media/libaudioclient/IAudioFlinger.cpp
@@ -332,6 +332,28 @@ status_t AudioFlingerClientAdapter::getMasterBalance(float* balance) const{
     return statusTFromBinderStatus(mDelegate->getMasterBalance(balance));
 }
 
+status_t AudioFlingerClientAdapter::setAppVolume(const String8& packageName, const float value) {
+    std::string packageNameAidl = VALUE_OR_RETURN_STATUS(
+            legacy2aidl_String8_string(packageName));
+    return mDelegate->setAppVolume(packageNameAidl, value).transactionError();
+}
+
+status_t AudioFlingerClientAdapter::setAppMute(const String8& packageName, const bool value) {
+    std::string packageNameAidl = VALUE_OR_RETURN_STATUS(
+            legacy2aidl_String8_string(packageName));
+    return mDelegate->setAppMute(packageNameAidl, value).transactionError();
+}
+
+status_t AudioFlingerClientAdapter::listAppVolumes(std::vector<media::AppVolume>* vols) {
+    std::vector<media::AppVolumeData> aidlRet;
+    RETURN_STATUS_IF_ERROR(mDelegate->listAppVolumes(&aidlRet).transactionError());
+    if (vols != nullptr) {
+        *vols = VALUE_OR_RETURN_STATUS(
+            convertContainer<std::vector<media::AppVolume>>(aidlRet, media::aidl2legacy_AppVolume));
+    }
+    return OK;
+}
+
 status_t AudioFlingerClientAdapter::setStreamVolume(audio_stream_type_t stream, float value,
                                                     audio_io_handle_t output) {
     AudioStreamType streamAidl = VALUE_OR_RETURN_STATUS(
@@ -993,6 +1015,26 @@ Status AudioFlingerServerAdapter::getMasterBalance(float* _aidl_return) {
     return Status::fromStatusT(mDelegate->getMasterBalance(_aidl_return));
 }
 
+Status AudioFlingerServerAdapter::setAppVolume(const std::string& packageName, const float value) {
+    String8 packageNameLegacy = VALUE_OR_RETURN_BINDER(
+            aidl2legacy_string_view_String8(packageName));
+    return Status::fromStatusT(mDelegate->setAppVolume(packageNameLegacy, value));
+}
+
+Status AudioFlingerServerAdapter::setAppMute(const std::string& packageName, const bool value) {
+    String8 packageNameLegacy = VALUE_OR_RETURN_BINDER(
+            aidl2legacy_string_view_String8(packageName));
+    return Status::fromStatusT(mDelegate->setAppMute(packageNameLegacy, value));
+}
+
+Status AudioFlingerServerAdapter::listAppVolumes(std::vector<media::AppVolumeData>* _aidl_return) {
+    std::vector<media::AppVolume> resultLegacy;
+    RETURN_BINDER_IF_ERROR(mDelegate->listAppVolumes(&resultLegacy));
+    *_aidl_return = VALUE_OR_RETURN_BINDER(convertContainer<std::vector<media::AppVolumeData>>(
+            resultLegacy, media::legacy2aidl_AppVolume));
+    return Status::ok();
+}
+
 Status AudioFlingerServerAdapter::setStreamVolume(AudioStreamType stream, float value,
                                                   int32_t output) {
     audio_stream_type_t streamLegacy = VALUE_OR_RETURN_BINDER(
diff --git a/media/libaudioclient/aidl/android/media/IAudioFlingerService.aidl b/media/libaudioclient/aidl/android/media/IAudioFlingerService.aidl
index 6412810b6d..b193b06810 100644
--- a/media/libaudioclient/aidl/android/media/IAudioFlingerService.aidl
+++ b/media/libaudioclient/aidl/android/media/IAudioFlingerService.aidl
@@ -16,6 +16,7 @@
 
 package android.media;
 
+import android.media.AppVolumeData;
 import android.media.AudioPatchFw;
 import android.media.AudioPolicyConfig;
 import android.media.AudioPortFw;
@@ -92,6 +93,10 @@ interface IAudioFlingerService {
     void setMasterBalance(float balance);
     float getMasterBalance();
 
+    void setAppVolume(@utf8InCpp String packageName, float value);
+    void setAppMute(@utf8InCpp String packageName, boolean muted);
+    AppVolumeData[] listAppVolumes();
+
     /*
      * Set/gets stream type state. This will probably be used by
      * the preference panel, mostly.
diff --git a/media/libaudioclient/include/media/AudioSystem.h b/media/libaudioclient/include/media/AudioSystem.h
index 8f8c9ddf5f..5c0a1f2a9e 100644
--- a/media/libaudioclient/include/media/AudioSystem.h
+++ b/media/libaudioclient/include/media/AudioSystem.h
@@ -40,6 +40,7 @@
 #include <android/media/audio/common/AudioMMapPolicyType.h>
 #include <android/media/audio/common/AudioPort.h>
 #include <media/AidlConversionUtil.h>
+#include <media/AppVolume.h>
 #include <media/AudioContainers.h>
 #include <media/AudioDeviceTypeAddr.h>
 #include <media/AudioPolicy.h>
@@ -769,6 +770,10 @@ public:
 
     static int32_t getAAudioHardwareBurstMinUsec();
 
+    static status_t setAppVolume(const String8& packageName, const float value);
+    static status_t setAppMute(const String8& packageName, const bool value);
+    static status_t listAppVolumes(std::vector<media::AppVolume> *vols);
+
 private:
 
     class AudioFlingerClient: public IBinder::DeathRecipient, public media::BnAudioFlingerClient
diff --git a/media/libaudioclient/include/media/IAudioFlinger.h b/media/libaudioclient/include/media/IAudioFlinger.h
index 2e2ef657ca..906d345f98 100644
--- a/media/libaudioclient/include/media/IAudioFlinger.h
+++ b/media/libaudioclient/include/media/IAudioFlinger.h
@@ -25,6 +25,7 @@
 #include <utils/Errors.h>
 #include <binder/IInterface.h>
 #include <media/AidlConversion.h>
+#include <media/AppVolume.h>
 #include <media/AudioClient.h>
 #include <media/AudioCommonTypes.h>
 #include <media/DeviceDescriptorBase.h>
@@ -384,6 +385,10 @@ public:
     virtual status_t supportsBluetoothVariableLatency(bool* support) = 0;
 
     virtual status_t getAudioPolicyConfig(media::AudioPolicyConfig* output) = 0;
+
+    virtual status_t setAppVolume(const String8& packageName, const float value) = 0;
+    virtual status_t setAppMute(const String8& packageName, const bool value) = 0;
+    virtual status_t listAppVolumes(std::vector<media::AppVolume> *vols) = 0;
 };
 
 /**
@@ -499,6 +504,10 @@ public:
     status_t invalidateTracks(const std::vector<audio_port_handle_t>& portIds) override;
     status_t getAudioPolicyConfig(media::AudioPolicyConfig* output) override;
 
+    status_t setAppVolume(const String8& packageName, const float value) override;
+    status_t setAppMute(const String8& packageName, const bool value) override;
+    status_t listAppVolumes(std::vector<media::AppVolume> *vols) override;
+
 private:
     const sp<media::IAudioFlingerService> mDelegate;
 };
@@ -599,6 +608,9 @@ public:
             INVALIDATE_TRACKS = media::BnAudioFlingerService::TRANSACTION_invalidateTracks,
             GET_AUDIO_POLICY_CONFIG =
                     media::BnAudioFlingerService::TRANSACTION_getAudioPolicyConfig,
+            SET_APP_VOLUME = media::BnAudioFlingerService::TRANSACTION_setAppVolume,
+            SET_APP_MUTE = media::BnAudioFlingerService::TRANSACTION_setAppMute,
+            LIST_APP_VOLUMES = media::BnAudioFlingerService::TRANSACTION_listAppVolumes,
         };
 
     protected:
@@ -732,6 +744,10 @@ public:
                                  sp<media::ISoundDose>* _aidl_return) override;
     Status invalidateTracks(const std::vector<int32_t>& portIds) override;
     Status getAudioPolicyConfig(media::AudioPolicyConfig* _aidl_return) override;
+
+    Status setAppVolume(const std::string& packageName, const float value) override;
+    Status setAppMute(const std::string& packageName, const bool value) override;
+    Status listAppVolumes(std::vector<media::AppVolumeData> *vols) override;
 private:
     const sp<AudioFlingerServerAdapter::Delegate> mDelegate;
 };
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 02531bd167..bf0d110725 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -1244,6 +1244,15 @@ status_t AudioFlinger::createTrack(const media::CreateTrackRequest& _input,
         output.portId = portId;
 
         if (lStatus == NO_ERROR) {
+            // set volume
+            String8 trackCreatorPackage = track->getPackageName();
+            if (!trackCreatorPackage.isEmpty() &&
+                mAppVolumeConfigs.find(trackCreatorPackage) != mAppVolumeConfigs.end()) {
+                media::AppVolume config = mAppVolumeConfigs[trackCreatorPackage];
+                track->setAppMute(config.muted);
+                track->setAppVolume(config.volume);
+            }
+
             // no risk of deadlock because AudioFlinger::mLock is held
             Mutex::Autolock _dl(thread->mLock);
             // Connect secondary outputs. Failure on a secondary output must not imped the primary
@@ -2120,6 +2129,61 @@ uint32_t AudioFlinger::getInputFramesLost(audio_io_handle_t ioHandle) const
     return 0;
 }
 
+
+status_t AudioFlinger::listAppVolumes(std::vector<media::AppVolume> *vols)
+{
+    std::set<media::AppVolume> volSet;
+    Mutex::Autolock _l(mLock);
+    for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
+        sp<PlaybackThread> thread = mPlaybackThreads.valueAt(i);
+        thread->listAppVolumes(volSet);
+    }
+
+    vols->insert(vols->begin(), volSet.begin(), volSet.end());
+
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::setAppVolume(const String8& packageName, const float value)
+{
+    Mutex::Autolock _l(mLock);
+    for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
+        sp<PlaybackThread> t = mPlaybackThreads.valueAt(i);
+        t->setAppVolume(packageName, value);
+    }
+
+    if (mAppVolumeConfigs.find(packageName) == mAppVolumeConfigs.end()) {
+        media::AppVolume vol;
+        vol.packageName = packageName;
+        vol.volume = value;
+        vol.muted = false;
+        mAppVolumeConfigs[packageName] = vol;
+    } else {
+        mAppVolumeConfigs[packageName].volume = value;
+    }
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::setAppMute(const String8& packageName, const bool value)
+{
+    Mutex::Autolock _l(mLock);
+    for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
+        sp<PlaybackThread> t = mPlaybackThreads.valueAt(i);
+        t->setAppMute(packageName, value);
+    }
+
+    if (mAppVolumeConfigs.find(packageName) == mAppVolumeConfigs.end()) {
+        media::AppVolume vol;
+        vol.packageName = packageName;
+        vol.volume = 1.0f;
+        vol.muted = value;
+        mAppVolumeConfigs[packageName] = vol;
+    } else {
+        mAppVolumeConfigs[packageName].muted = value;
+    }
+    return NO_ERROR;
+}
+
 status_t AudioFlinger::setVoiceVolume(float value)
 {
     status_t ret = initCheck();
@@ -4807,7 +4871,9 @@ status_t AudioFlinger::onTransactWrapper(TransactionCode code,
         case TransactionCode::UPDATE_SECONDARY_OUTPUTS:
         case TransactionCode::SET_BLUETOOTH_VARIABLE_LATENCY_ENABLED:
         case TransactionCode::IS_BLUETOOTH_VARIABLE_LATENCY_ENABLED:
-        case TransactionCode::SUPPORTS_BLUETOOTH_VARIABLE_LATENCY: {
+        case TransactionCode::SUPPORTS_BLUETOOTH_VARIABLE_LATENCY:
+        case TransactionCode::SET_APP_VOLUME:
+        case TransactionCode::SET_APP_MUTE: {
             if (!isServiceUid(IPCThreadState::self()->getCallingUid())) {
                 ALOGW("%s: transaction %d received from PID %d unauthorized UID %d",
                       __func__, code, IPCThreadState::self()->getCallingPid(),
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index 7058a25495..d5d06d55ae 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -364,6 +364,14 @@ private:
     Vector< sp<NBLog::Writer> > mUnregisteredWriters;
     Mutex               mUnregisteredWritersLock;
 
+public:
+    status_t    setAppVolume(const String8& packageName, const float value);
+    status_t    setAppMute(const String8& packageName, const bool value);
+    status_t    listAppVolumes(std::vector<media::AppVolume> *vols);
+
+private:
+    std::map<String8, media::AppVolume>  mAppVolumeConfigs;
+
 public:
     // Life cycle of gAudioFlinger and AudioFlinger:
     //
diff --git a/services/audioflinger/PlaybackTracks.h b/services/audioflinger/PlaybackTracks.h
index 57655d55a0..fc8e137317 100644
--- a/services/audioflinger/PlaybackTracks.h
+++ b/services/audioflinger/PlaybackTracks.h
@@ -153,7 +153,7 @@ public:
     sp<media::VolumeShaper::State> getVolumeShaperState(int id);
     sp<media::VolumeHandler>   getVolumeHandler() { return mVolumeHandler; }
     /** Set the computed normalized final volume of the track.
-     * !masterMute * masterVolume * streamVolume * averageLRVolume */
+     * !masterMute * !appMuted * masterVolume * streamVolume * averageLRVolume * appVolume */
     void                setFinalVolume(float volumeLeft, float volumeRight);
     float               getFinalVolume() const { return mFinalVolume; }
     void                getFinalVolume(float* left, float* right) const {
@@ -161,6 +161,13 @@ public:
                             *right = mFinalVolumeRight;
     }
 
+    void                setAppVolume(float volume);
+    float               getAppVolume() const { return mAppVolume; }
+    void                setAppMute(bool val);
+    bool                isAppMuted() { return mAppMuted; }
+
+    String8             getPackageName() const { return mPackageName; }
+
     using SourceMetadatas = std::vector<playback_track_metadata_v7_t>;
     using MetadataInserter = std::back_insert_iterator<SourceMetadatas>;
     /** Copy the track metadata in the provided iterator. Thread safe. */
@@ -347,6 +354,8 @@ private:
         for (auto& tp : mTeePatches) { f(tp.patchTrack); }
     };
 
+    String8             mPackageName;
+
     size_t              mPresentationCompleteFrames = 0; // (Used for Mixed tracks)
                                     // The number of frames written to the
                                     // audio HAL when this track is considered fully rendered.
@@ -372,6 +381,8 @@ private:
                                           // volume
     float               mFinalVolumeRight; // combine master volume, stream type volume and track
                                            // volume
+    float               mAppVolume;  // volume control for separate processes
+    bool                mAppMuted;
     sp<AudioTrackServerProxy>  mAudioTrackServerProxy;
     bool                mResumeToStopping; // track was paused in stopping state.
     bool                mFlushHwPending; // track requests for thread flush
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index 8447de6836..25a9bb2be0 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -24,6 +24,7 @@
 #include <math.h>
 #include <fcntl.h>
 #include <memory>
+#include <set>
 #include <sstream>
 #include <string>
 #include <linux/futex.h>
@@ -2694,6 +2695,43 @@ ssize_t AudioFlinger::PlaybackThread::Tracks<T>::remove(const sp<T> &track)
     return index;
 }
 
+void AudioFlinger::PlaybackThread::listAppVolumes(std::set<media::AppVolume> &container)
+{
+    Mutex::Autolock _l(mLock);
+    for (sp<Track> track : mTracks) {
+        if (!track->getPackageName().isEmpty()) {
+            media::AppVolume av;
+            av.packageName = track->getPackageName();
+            av.muted = track->isAppMuted();
+            av.volume = track->getAppVolume();
+            av.active = mActiveTracks.indexOf(track) >= 0;
+            container.insert(av);
+        }
+    }
+}
+
+status_t AudioFlinger::PlaybackThread::setAppVolume(const String8& packageName, const float value)
+{
+    Mutex::Autolock _l(mLock);
+    for (sp<Track> track : mTracks) {
+        if (packageName == track->getPackageName()) {
+            track->setAppVolume(value);
+        }
+    }
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::PlaybackThread::setAppMute(const String8& packageName, const bool value)
+{
+    Mutex::Autolock _l(mLock);
+    for (sp<Track> track : mTracks) {
+        if (packageName == track->getPackageName()) {
+            track->setAppMute(value);
+        }
+    }
+    return NO_ERROR;
+}
+
 uint32_t AudioFlinger::PlaybackThread::correctLatency_l(uint32_t latency) const
 {
     return latency;
@@ -5556,10 +5594,12 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTrac
                 }
                 sp<AudioTrackServerProxy> proxy = track->mAudioTrackServerProxy;
                 float volume;
-                if (track->isPlaybackRestricted() || mStreamTypes[track->streamType()].mute) {
+                if (track->isPlaybackRestricted() ||
+                        mStreamTypes[track->streamType()].mute || track->isAppMuted()) {
                     volume = 0.f;
                 } else {
-                    volume = masterVolume * mStreamTypes[track->streamType()].volume;
+                    volume = masterVolume * mStreamTypes[track->streamType()].volume
+                                          * track->getAppVolume();
                 }
 
                 handleVoipVolume_l(&volume);
@@ -5727,13 +5767,15 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTrac
             uint32_t vl, vr;       // in U8.24 integer format
             float vlf, vrf, vaf;   // in [0.0, 1.0] float format
             // read original volumes with volume control
-            float v = masterVolume * mStreamTypes[track->streamType()].volume;
+            float v = masterVolume * mStreamTypes[track->streamType()].volume
+                                   * track->getAppVolume();
             // Always fetch volumeshaper volume to ensure state is updated.
             const sp<AudioTrackServerProxy> proxy = track->mAudioTrackServerProxy;
             const float vh = track->getVolumeHandler()->getVolume(
                     track->mAudioTrackServerProxy->framesReleased()).first;
 
-            if (mStreamTypes[track->streamType()].mute || track->isPlaybackRestricted()) {
+            if (mStreamTypes[track->streamType()].mute
+                    || track->isPlaybackRestricted() || track->isAppMuted()) {
                 v = 0;
             }
 
@@ -6475,11 +6517,13 @@ void AudioFlinger::DirectOutputThread::processVolume_l(Track *track, bool lastTr
 
     const bool clientVolumeMute = (left == 0.f && right == 0.f);
 
-    if (mMasterMute || mStreamTypes[track->streamType()].mute || track->isPlaybackRestricted()) {
+    if (mMasterMute || mStreamTypes[track->streamType()].mute
+            || track->isPlaybackRestricted() || track->isAppMuted()) {
         left = right = 0;
     } else {
         float typeVolume = mStreamTypes[track->streamType()].volume;
-        const float v = mMasterVolume * typeVolume * shaperVolume;
+        float appVolume = track->getAppVolume();
+        const float v = mMasterVolume * typeVolume * shaperVolume * appVolume;
 
         if (left > GAIN_FLOAT_UNITY) {
             left = GAIN_FLOAT_UNITY;
diff --git a/services/audioflinger/Threads.h b/services/audioflinger/Threads.h
index b5332e18db..343f3e0c79 100644
--- a/services/audioflinger/Threads.h
+++ b/services/audioflinger/Threads.h
@@ -973,6 +973,10 @@ public:
 
                 void        setVolumeForOutput_l(float left, float right) const override;
 
+                status_t    setAppVolume(const String8& packageName, const float value);
+                status_t    setAppMute(const String8& packageName, const bool muted);
+                void        listAppVolumes(std::set<media::AppVolume> &container);
+
                 sp<Track>   createTrack_l(
                                 const sp<AudioFlinger::Client>& client,
                                 audio_stream_type_t streamType,
diff --git a/services/audioflinger/Tracks.cpp b/services/audioflinger/Tracks.cpp
index ec5fbdaaf4..ba5f3308db 100644
--- a/services/audioflinger/Tracks.cpp
+++ b/services/audioflinger/Tracks.cpp
@@ -692,6 +692,20 @@ AudioFlinger::PlaybackThread::Track::Track(
     ALOGV_IF(sharedBuffer != 0, "%s(%d): sharedBuffer: %p, size: %zu",
             __func__, mId, sharedBuffer->unsecurePointer(), sharedBuffer->size());
 
+    /* get package name */
+    PermissionController permissionController;
+    Vector<String16> packages;
+    permissionController.getPackagesForUid(uid(), packages);
+    if (!packages.isEmpty()) {
+        mPackageName = String8(packages[0]);
+    } else {
+        mPackageName = "";
+    }
+
+    /* init app volume */
+    mAppMuted = false;
+    mAppVolume = 1.0f;
+
     if (mCblk == NULL) {
         return;
     }
@@ -1434,6 +1448,16 @@ void AudioFlinger::PlaybackThread::Track::setFinalVolume(float volumeLeft, float
     }
 }
 
+void AudioFlinger::PlaybackThread::Track::setAppVolume(float volume)
+{
+    mAppVolume = volume;
+}
+
+void AudioFlinger::PlaybackThread::Track::setAppMute(bool val)
+{
+    mAppMuted = val;
+}
+
 void AudioFlinger::PlaybackThread::Track::copyMetadataTo(MetadataInserter& backInserter) const
 {
     // Do not forward metadata for PatchTrack with unspecified stream type
-- 
2.25.1

